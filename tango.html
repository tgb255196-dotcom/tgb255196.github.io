<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‹±æ–‡å­—é¦–å­—å°¾çµ„åˆéŠæˆ²</title>
    <style>
        /* CSS æ¨£å¼ */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f4f7f6;
            margin: 0;
            padding: 20px;
        }

        h1 {
            color: #2c3e50;
        }

        /* æŒ‘æˆ°å€åŸŸ */
        #challenge-area {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 30px 0;
            padding: 20px;
            border: 2px solid #3498db;
            border-radius: 12px;
            background-color: #ecf0f1;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            min-height: 150px;
            width: 80%;
            max-width: 900px;
        }

        /* çµ„åˆå¡ç‰‡æ¨£å¼ */
        .component-slot, .component-card {
            min-width: 100px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            font-weight: bold;
            margin: 0 5px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        /* æ’æ§½æ¨£å¼ (ç›®æ¨™æ”¾ç½®å€) */
        .component-slot {
            background-color: #bdc3c7;
            border: 2px dashed #7f8c8d;
            color: #7f8c8d;
            opacity: 0.8;
        }
        
        /* ä¸åŒçš„å¡ç‰‡é¡è‰² */
        .prefix { background-color: #e74c3c; color: white; } /* ç´…è‰² */
        .root { background-color: #2ecc71; color: white; } /* ç¶ è‰² - æŒ‘æˆ°çš„ä¸»é«” */
        .suffix { background-color: #3498db; color: white; } /* è—è‰² */

        /* çµ„åˆçµæœå€å¡Š */
        #result-display {
            font-size: 2em;
            margin-top: 20px;
            min-height: 40px;
            color: #2c3e50;
            font-weight: bold;
            text-align: center;
        }

        /* æŒ‰éˆ•æ¨£å¼ */
        button {
            padding: 10px 20px;
            font-size: 1em;
            margin: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #check-button {
            background-color: #f39c12; /* é»ƒè‰² */
            color: white;
        }
        #check-button:hover { background-color: #e67e22; }

        #next-button {
            background-color: #1abc9c; /* é’è‰² */
            color: white;
            display: none; /* åˆå§‹éš±è— */
        }
        #next-button:hover { background-color: #16a085; }

        /* é¸é …å¡ç‰Œå€ */
        #options-area {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
            border-top: 1px solid #ccc;
            padding-top: 20px;
            width: 80%;
            max-width: 900px;
        }

        .option-card {
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            cursor: grab;
            margin: 5px;
        }
    </style>
</head>
<body>

    <h1>ğŸ§  è‹±æ–‡å­—é¦–å­—å°¾çµ„åˆéŠæˆ² ğŸ—£ï¸</h1>

    <div id="challenge-area">
        <div class="component-slot prefix-slot" data-type="prefix" data-is-occupied="false" onclick="clearSlot(this)">å­—é¦– (Prefix)</div>
        <div class="component-slot root-slot" data-type="root" data-is-occupied="false" onclick="clearSlot(this)">å­—æ ¹ (Root)</div>
        <div class="component-slot suffix-slot" data-type="suffix" data-is-occupied="false" onclick="clearSlot(this)">å­—å°¾ (Suffix)</div>
    </div>

    <div id="result-display"></div>
    <div id="definition-display"></div>

    <div>
        <button id="check-button" onclick="checkCombination()">æª¢æŸ¥çµ„åˆä¸¦ç™¼éŸ³</button>
        <button id="next-button" onclick="startNewChallenge()">ä¸‹ä¸€é¡Œ</button>
    </div>

    <hr style="width: 80%; margin: 20px 0;">

    <h2>å¡ç‰‡é¸é …å€ (é»æ“Šå¡ç‰‡æ”¾å…¥æ’æ§½)</h2>
    <div id="options-area">
        </div>
    <script>
        // === JSON è³‡æ–™çµæ§‹ (æ“´å……ç‰ˆ) ===
        const GAME_DATA = {
            "prefixes": [
                {"element": "un-", "meaning": "not, opposite of"},
                {"element": "re-", "meaning": "again, back"},
                {"element": "dis-", "meaning": "not, away"},
                {"element": "pre-", "meaning": "before"},
                {"element": "sub-", "meaning": "under"},
                {"element": "", "meaning": "None (No prefix)"} // æ–°å¢ç©ºå­—é¦–é¸é …ï¼Œç”¨æ–¼ä¸éœ€è¦å­—é¦–çš„å–®å­—
            ],
            "roots": [
                {"element": "happy", "meaning": "joyful, pleased"},
                {"element": "view", "meaning": "see, look"},
                {"element": "agree", "meaning": "accept, concur"},
                {"element": "port", "meaning": "carry"},
                {"element": "dict", "meaning": "say, speak"},
                {"element": "read", "meaning": "take in words"}, // æ–°å¢ read å­—æ ¹
                {"element": "new", "meaning": "recently made"}, // æ–°å¢ new å­—æ ¹
            ],
            "suffixes": [
                {"element": "-ly", "meaning": "in a certain way (adverb)"},
                {"element": "-able", "meaning": "capable of (adjective)"},
                {"element": "-ment", "meaning": "result of (noun)"},
                {"element": "-tion", "meaning": "state of (noun)"},
                {"element": "-er", "meaning": "one who does (noun)"},
                {"element": "", "meaning": "None (No suffix)"} // æ–°å¢ç©ºå­—å°¾é¸é …ï¼Œç”¨æ–¼ä¸éœ€è¦å­—å°¾çš„å–®å­—
            ],
            "valid_combinations": [
                // p: prefix, r: root, s: suffix
                {"word": "unhappy", "p": "un-", "r": "happy", "s": "", "def": "Not happy; sad."},
                {"word": "unhappily", "p": "un-", "r": "happy", "s": "-ly", "def": "In a sad way."},
                {"word": "disagree", "p": "dis-", "r": "agree", "s": "", "def": "To have a different opinion."},
                {"word": "disagreement", "p": "dis-", "r": "agree", "s": "-ment", "def": "A difference of opinion."},
                {"word": "review", "p": "re-", "r": "view", "s": "", "def": "To look at something again."},
                {"word": "predict", "p": "pre-", "r": "dict", "s": "", "def": "To say what will happen in the future."},
                {"word": "portable", "p": "", "r": "port", "s": "-able", "def": "Easily carried or transported."}, // å­—é¦–ç‚ºç©º
                {"word": "transport", "p": "trans-", "r": "port", "s": "", "def": "To carry or move (something) from one place to another."},
                {"word": "reader", "p": "", "r": "read", "s": "-er", "def": "One who reads."}, // å­—é¦–ç‚ºç©º
                {"word": "newly", "p": "", "r": "new", "s": "-ly", "def": "Recently; just now."},
                {"word": "happy", "p": "", "r": "happy", "s": "", "def": "Feeling or showing pleasure or contentment."} // ç´”å­—æ ¹
            ]
        };

        // --- å…¨åŸŸè®Šæ•¸ ---
        // ä¿®æ­£ï¼šç¾åœ¨ä½¿ç”¨æ’æ§½çš„ data-element ä¾†åˆ¤æ–·é¸ä¸­çš„å…§å®¹ï¼Œè®“è®Šæ•¸æ›´ç©©å®š
        const resultDisplay = document.getElementById('result-display');
        const definitionDisplay = document.getElementById('definition-display');
        const prefixSlot = document.querySelector('.prefix-slot');
        const rootSlot = document.querySelector('.root-slot'); 
        const suffixSlot = document.querySelector('.suffix-slot');
        const optionsArea = document.getElementById('options-area');
        const checkButton = document.getElementById('check-button');
        const nextButton = document.getElementById('next-button');
        
        // Web Speech API
        const synth = window.speechSynthesis;
        let selectedVoice = null;

        // --- èªéŸ³åŠŸèƒ½è¨­å®š (ä¿æŒä¸è®Š) ---
        function setupVoice() {
            if (!('speechSynthesis' in window)) {
                alert('æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³åˆæˆåŠŸèƒ½ (TTS)ã€‚');
                return;
            }

            function populateVoiceList() {
                const voices = synth.getVoices();
                // å˜—è©¦é¸å–ä¸€å€‹ç¾å¼æˆ–è‹±å¼ç™¼éŸ³çš„èªéŸ³
                selectedVoice = voices.find(voice => 
                    voice.lang.startsWith('en-US') || voice.lang.startsWith('en-GB')
                );
            }

            populateVoiceList();
            if (synth.onvoiceschanged !== undefined) {
              synth.onvoiceschanged = populateVoiceList;
            }
        }

        // æ’­æ”¾èªéŸ³å‡½æ•¸
        function speakWord(text) {
            if (text === '') return;
            
            // é‡è¦ä¿®æ­£ï¼šå¦‚æœæ­£åœ¨æ’­æ”¾ï¼Œå…ˆå–æ¶ˆã€‚é€™è§£æ±ºäº†èªéŸ³è¢«é˜»æ“‹çš„å•é¡Œã€‚
            if (synth.speaking) {
                synth.cancel();
            }
            
            const utterance = new SpeechSynthesisUtterance(text);
            
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            }
            utterance.lang = 'en-US';
            utterance.rate = 1.0;
            
            synth.speak(utterance);
        }

        // --- éŠæˆ²é‚è¼¯ ---

        // 1. ç”Ÿæˆé¸é …å¡ç‰‡ (åŒ…å«å­—é¦–ã€å­—æ ¹ã€å­—å°¾å’Œ None é¸é …)
        function renderOptions() {
            optionsArea.innerHTML = ''; 
            
            // åˆä½µæ‰€æœ‰é¸é …
            const allOptions = [
                ...GAME_DATA.prefixes.map(p => ({ ...p, type: 'prefix' })),
                ...GAME_DATA.roots.map(r => ({ ...r, type: 'root' })),
                ...GAME_DATA.suffixes.map(s => ({ ...s, type: 'suffix' }))
            ].filter(item => item.element !== ""); // éæ¿¾æ‰ None é¸é …ï¼Œæˆ‘å€‘å°‡ None å–®ç¨è™•ç†

            allOptions.sort(() => Math.random() - 0.5); // éš¨æ©Ÿæ’åº

            allOptions.forEach(item => {
                createOptionCard(item.element, item.type);
            });
            
            // æ–°å¢ "None" å¡ç‰‡ä½œç‚ºé¸é …ï¼Œè®“ç©å®¶å¯ä»¥é¸æ“‡ä¸ä½¿ç”¨å­—é¦–æˆ–å­—å°¾
            createOptionCard(GAME_DATA.prefixes.find(p => p.element === "").element, 'prefix', "ç„¡å­—é¦– (None)");
            createOptionCard(GAME_DATA.suffixes.find(s => s.element === "").element, 'suffix', "ç„¡å­—å°¾ (None)");
        }
        
        // è¼”åŠ©å‡½æ•¸ï¼šå‰µå»ºå–®ä¸€é¸é …å¡ç‰‡
        function createOptionCard(element, type, display_text = element) {
            const card = document.createElement('div');
            card.textContent = display_text;
            card.classList.add('component-card', 'option-card');
            card.classList.add(type);

            // è¨­ç½® data-element ç‚ºå¯¦éš›çš„å…ƒç´ å€¼ (å³ä½¿æ˜¯ç©ºå­—ä¸²ä¹Ÿéœ€è¦è¨­ç½®)
            card.dataset.element = element;
            card.dataset.type = type;
            
            // æª¢æŸ¥æ˜¯å¦å·²è¢«é¸ç”¨
            const isSelected = (prefixSlot.dataset.element === element && type === 'prefix') ||
                               (rootSlot.dataset.element === element && type === 'root') ||
                               (suffixSlot.dataset.element === element && type === 'suffix');

            if (!isSelected) {
                card.onclick = () => selectCard(card, type);
            } else {
                card.style.opacity = '0.3'; 
            }

            optionsArea.appendChild(card);
        }


        // 2. è™•ç†å¡ç‰‡é»æ“Š (é©ç”¨æ–¼å­—é¦–ã€å­—æ ¹ã€å­—å°¾)
        function selectCard(card, type) {
            const element = card.dataset.element;
            let slot;

            if (type === 'prefix') {
                slot = prefixSlot;
            } else if (type === 'root') {
                slot = rootSlot;
            } else {
                slot = suffixSlot;
            }

            // æ¸…ç©ºèˆŠå¡ç‰‡
            if (slot.dataset.element) {
                clearSlot(slot);
            }
            
            // æ›´æ–°æ’æ§½é¡¯ç¤ºå’Œè³‡æ–™
            // å¦‚æœæ˜¯ç©ºå­—ä¸²ï¼Œé¡¯ç¤º None
            slot.textContent = element === "" ? "None" : card.textContent;
            
            // é‡è¦ï¼šè¨­ç½® data-element ç‚ºå¯¦éš›çš„å…ƒç´ å€¼ (ä¾‹å¦‚: "un-", "happy", "-ly", æˆ– "")
            slot.dataset.element = element; 
            
            // ç²å–é¸é …å¡ç‰‡çš„å¯¦éš›é¡è‰²
            slot.style.backgroundColor = getComputedStyle(card).backgroundColor;
            slot.style.color = 'white';
            
            // éš±è—é¸é …å¡ç‰‡ (åƒ…å°é None çš„å¡ç‰‡éš±è—ï¼Œæˆ–å°æ‡‰çš„ None å¡ç‰‡)
            card.style.opacity = '0.3';
            card.onclick = null;
        }

        // 3. æ¸…ç©ºæ’æ§½ (é©ç”¨æ–¼å­—é¦–ã€å­—æ ¹ã€å­—å°¾)
        function clearSlot(slot) {
            const type = slot.dataset.type;
            const element = slot.dataset.element; // ç²å–è¦æ¸…é™¤çš„å…ƒç´ å€¼
            
            if (!element && element !== "") return; // å¦‚æœæ’æ§½æœ¬ä¾†å°±æ²’æ±è¥¿ï¼Œå‰‡é€€å‡º

            // æ¸…ç©ºæ’æ§½é¡¯ç¤ºå’Œè³‡æ–™
            slot.textContent = type === 'prefix' ? 'å­—é¦– (Prefix)' : (type === 'root' ? 'å­—æ ¹ (Root)' : 'å­—å°¾ (Suffix)');
            slot.style.backgroundColor = '#bdc3c7';
            slot.style.color = '#7f8c8d';
            slot.removeAttribute('data-element'); // æ¸…é™¤ data-element å±¬æ€§

            // è®“é¸é …å¡ç‰‡é‡æ–°å¯ç”¨
            const optionCardToRestore = Array.from(optionsArea.children).find(c => c.dataset.element === element);
            if(optionCardToRestore) {
                 optionCardToRestore.style.opacity = '1';
                 optionCardToRestore.onclick = () => selectCard(optionCardToRestore, type);
            }
        }

        // 4. æª¢æŸ¥çµ„åˆ (æ ¸å¿ƒé‚è¼¯)
        function checkCombination() {
            // å¾æ’æ§½çš„ data-element å±¬æ€§ä¸­ç²å–é¸ä¸­çš„å…ƒç´ ï¼Œç¢ºä¿å³ä½¿æ˜¯ç©ºå­—ä¸² ("") ä¹Ÿèƒ½æ­£ç¢ºç²å–
            const prefix = prefixSlot.dataset.element || ''; 
            const root = rootSlot.dataset.element || ''; 
            const suffix = suffixSlot.dataset.element || ''; 
            
            if (root === '') {
                definitionDisplay.textContent = 'âš ï¸ è«‹è‡³å°‘é¸æ“‡ä¸€å€‹å­—æ ¹ã€‚';
                definitionDisplay.style.color = '#e74c3c';
                return;
            }

            // çµ„åˆæˆå®Œæ•´çš„å­—ä¸² (ä½¿ç”¨ replace('-', '') ç§»é™¤é€£å­—è™Ÿ)
            const combinedWord = (prefix.replace('-', '') + root + suffix.replace('-', '')).toLowerCase();
            
            // æŸ¥æ‰¾æœ‰æ•ˆçµ„åˆ
            const match = GAME_DATA.valid_combinations.find(c => 
                c.p === prefix && c.r === root && c.s === suffix
            );

            resultDisplay.innerHTML = `çµ„åˆçµæœ: <span style="color:#c0392b;">${combinedWord}</span>`;
            
            if (match) {
                // æˆåŠŸ
                definitionDisplay.textContent = `âœ… æ­£ç¢º! å®šç¾©: ${match.def}`;
                definitionDisplay.style.color = '#27ae60';
                speakWord(match.word); // æ’­æ”¾å–®å­—èªéŸ³
                
                checkButton.style.display = 'none';
                nextButton.style.display = 'inline-block';
            } else {
                // å¤±æ•—
                definitionDisplay.textContent = 'âŒ éŒ¯èª¤! æ­¤çµ„åˆå¯èƒ½ä¸æ˜¯æ¨™æº–å–®å­—æˆ–åœ¨è©å½™åº«ä¸­ä¸å­˜åœ¨ã€‚';
                definitionDisplay.style.color = '#e74c3c';
                speakWord(combinedWord); // ä»å˜—è©¦ç™¼éŸ³ï¼Œè®“ç©å®¶è½åˆ°çµ„åˆçš„è²éŸ³
            }
        }

        // 5. é–‹å§‹æ–°æŒ‘æˆ° (æ¸…ç©ºå¾Œé‡æ–°ç”Ÿæˆé¸é …)
        function startNewChallenge() {
            // 1. æ¸…ç©ºæ‰€æœ‰æ’æ§½
            clearSlot(prefixSlot);
            clearSlot(rootSlot);
            clearSlot(suffixSlot);

            resultDisplay.textContent = '';
            definitionDisplay.textContent = '';
            checkButton.style.display = 'inline-block';
            nextButton.style.display = 'none';

            // 2. é‡æ–°æ¸²æŸ“æ‰€æœ‰é¸é …å¡ç‰‡
            renderOptions();
        }

        // --- éŠæˆ²åˆå§‹åŒ– ---
        document.addEventListener('DOMContentLoaded', () => {
            setupVoice();
            startNewChallenge(); 
        });
    </script>
</body>
</html>